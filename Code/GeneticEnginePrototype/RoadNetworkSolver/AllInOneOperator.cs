using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GeneticAlgorithm.Plugin;
using RoadNetworkDefinition;

namespace RoadNetworkSolver
{
    /// <summary>
    /// IGeneticOperator which applies Survival, Mutation and Conjugation to the best individuals of
    /// one generation to produce the next.
    /// 
    /// It uses the Mutate method of StepMutator and the Conjugate method of StepConjugator
    /// 
    /// This operator should only be used with populations generated by StepPopulator and StepCyclePopulator or
    /// as it assumes that the Edges only connect adjacent points.
    /// </summary>
    public class AllInOneOperator : IGeneticOperator
    {
        /// <summary>
        /// Initialise a new AllInOneOperator
        /// </summary>
        /// <param name="config">Configuration object (ignored)</param>
        public AllInOneOperator(object config)
        {
        }

        /// <summary>
        /// Process a generation to produce the individuals which will make up the next generation
        /// </summary>
        /// <param name="source">The current generation</param>
        /// <param name="destination">An empty collection of individuals to be populated</param>
        public void Operate(IGeneration source, ArrayList destination)
        {
            int index1 = 1;

            while (destination.Count < source.Count)
            {
                RoadNetwork parent1 = (RoadNetwork)source[index1].Individual;
                destination.Add(new RoadNetwork(parent1));

                if (destination.Count < source.Count)
                {
                    destination.Add(StepMutator.Mutate(parent1));
                }

                int index2 = 0;

                while (index2 < index1 && destination.Count < source.Count)
                {
                    RoadNetwork parent2 = (RoadNetwork)source[index2].Individual;

                    RoadNetwork child1;
                    RoadNetwork child2;

                    StepConjugator.Conjugate(parent1, parent2, out child1, out child2);

                    destination.Add(child1);

                    if (destination.Count < source.Count)
                    {
                        destination.Add(child2);
                    }

                    index2++;
                }

                index1++;
            }
        }
    }
}
